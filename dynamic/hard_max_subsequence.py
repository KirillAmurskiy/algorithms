"""Наибольшая невозрастающая подпоследовательность.
Дано целое число 1≤n≤10^5 и массив A[1…n], содержащий неотрицательные целые числа, не
превосходящие 10^9. Найдите наибольшую невозрастающую подпоследовательность в A.
В первой строке выведите её длину k, во второй — её индексы 1≤i1<i2<…<ik≤n
(таким образом, A[i_1]≥A[i_2]≥…≥A[i_n]).

Максимальное значение n=10^5, т.о. нам не подойдет обычный алгоритм сложности O(n^2).

Выбранный алгоритм имеет сложность O(n*logn) - один раз проходим по массиву длины n,
на каждой итерации ищем место для очередного элемента бинарным поиском - logn."""


def bisect_right(arr, val):
    """Находим idx в отсортированном массиве для которого arr[0:idx-1] >= val.
    Практический смысл idx:
    1. По этому индексу нужно вставить val, чтобы массив остался отсортированным по убыванию.
    2. idx=количество элементов в массиве больших либо равных данному.
    Если в массиве все элементы меньше val, то idx=0.
    Если в массиве все элементы больше либо равны val, то idx=len(arr)."""
    l, r = 0, len(arr)
    m = 0

    while l < r:
        m = (l + r) // 2
        if arr[m] < val:
            r = m
        else:
            l = m + 1

    return l


def main():
    # бесконечности в данной задаче
    pos_inf = 10 ** 10
    neg_inf = -1

    n = int(input())
    # исходный массив
    a = [int(i) for i in input().split()]
    # d[i] = ЗНАЧЕНИЕ последнего элемента в последовательности длины i
    d = [neg_inf] * (n + 1)
    d[0] = pos_inf
    # p[i] = ИНДЕКС последнего элемента в последовательности длины i
    a_idx = [-1] * (n + 1)
    # prev[i] - ИНДЕКС предыдущего элемента в оптимальной последовательности для элемента a[i]
    prev_idx = [-1] * n

    for i in range(n):
        # Находим индекс первого элемента в d, который меньше a[i].
        # Мы можем присоединить a[i] к последовательности, заканчивающейся
        # в элементе d[idx-1], т.к. d[idx-1] - меньше a[i]. Присоединение
        # к этому элементу оптимальное, т.к. это самая длинная последовательность
        # к которой можно присоединить a[i].
        # Т.о. idx - есть максимальная длина последовательности, которая
        # заканчивается на a[i] в массиве a[0:i]
        idx = bisect_right(d, a[i])
        d[idx] = a[i]
        # Чтобы можно было восстановить последовательность,
        # запоминаем индексы предыдущего в последовательности
        prev_idx[i] = a_idx[idx - 1]
        # и последнего в последовательности.
        a_idx[idx] = i

    # Находим максимальную длину последовательности
    k = n
    for i in range(n, -1, -1):
        if d[i] > neg_inf:
            k = i
            break

    # Восстанавливаем ее, получится с конца в начало.
    sequence = [-1] * k
    last_idx = a_idx[k]
    sequence[0] = last_idx
    for i in range(1, k):
        sequence[i] = prev_idx[sequence[i - 1]]

    # Разворачиваем, чтобы был правильный порядок.
    sequence.reverse()

    # Increment - это нужно для вывода ответа.
    for i in range(k):
        sequence[i] += 1

    print(k)
    print(*sequence)


if __name__ == "__main__":
    main()
